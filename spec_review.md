# 算法SDK规范 (v0.2.0) 评审报告

**评审对象**: `spec.md` (v0.2.0)
**评审时间**: 2025-11-20
**评审人**: Antigravity

---

## 1. 总体评价

该规范文档结构清晰，定义了平台与算法之间的解耦边界，特别针对工业现场的"离线部署"、"资源受限"、"高稳定性"要求做了针对性设计。v0.2.0 版本引入的"单实例支持多PID"设计是对 v0.1.0 的重大改进，有效解决了多产品切换时的内存冗余问题。

## 2. 架构合理性分析

### 2.1. 平台与算法解耦
*   **评价**: **优秀**
*   **分析**: 通过 SDK (`procvision_algorithm_sdk`) 定义标准接口，算法团队只需关注业务逻辑，平台方负责调度、通信和资源管理。这种依赖倒置的设计使得算法可以独立迭代，且便于平台统一升级。

### 2.2. 进程间通信 (IPC)
*   **评价**: **合理且稳健**
*   **分析**:
    *   **控制流**: 使用 Stdin/Stdout + JSON 协议。这种方式跨语言（虽然目前限定 Python）、易调试、无额外网络端口依赖，非常适合工控机环境。
    *   **数据流**: 使用共享内存传输图像。这是工业视觉的高性能标准做法，避免了 Base64 编码/解码的 CPU 开销和 Socket 传输的延迟。

### 2.3. 生命周期管理 (v0.2.0 改进)
*   **评价**: **显著提升**
*   **分析**: v0.1.0 的"一PID一实例"会导致 N 个产品消耗 N 倍内存。v0.2.0 改为在 `execute` 中传入 `pid`，使得算法可以复用通用模型（如 YOLO 骨干网络），仅切换 Head 或配置参数。这对于显存有限的工控机（如 RTX 4060）至关重要。

## 3. 场景覆盖度分析

### 3.1. 核心检测流程
*   **覆盖度**: **100%**
*   **分析**:
    *   `pre_execute`: 覆盖了"检测前检查"（光照、位置、标定），支持快速失败（Fail Fast），避免无效检测浪费算力。
    *   `execute`: 覆盖了核心业务逻辑。
    *   `reset`: 覆盖了异常中断后的状态清理。

### 3.2. 异常处理
*   **覆盖度**: **高**
*   **分析**: 明确区分了 `Recoverable`（外部环境问题，可重试）和 `Fatal`（代码/模型问题，需停机）。这直接对应了产线的"报警灯"逻辑（黄灯 vs 红灯），非常贴合实际业务。

### 3.3. 交互与反馈
*   **覆盖度**: **高**
*   **分析**:
    *   `message`: 给操作员看（人读）。
    *   `overlay`: 给 UI 绘图用（可视化）。
    *   `diagnostics`: 给 MES/工程师看（数据分析）。
    *   **亮点**: v0.2.0 明确禁止在 `overlay` 中返回 Base64 图片，只返回坐标。这是一个防止内存泄漏和带宽滥用的极佳约束。

## 4. 优化建议 (避免过度设计)

虽然规范已经很完善，但在实际落地中，为了避免"过度设计"导致开发繁琐，提出以下优化点：

### 4.1. 资源加载策略 (Lazy Loading vs Eager Loading)
*   **现状**: `setup()` 钩子用于初始化。
*   **风险**: 如果一个算法包支持 20 个 PID，且每个 PID 都有独立的模型文件，在 `setup()` 中一次性加载可能会撑爆内存（OOM），即使当前只生产其中 1 个产品。
*   **建议**:
    *   **优化**: 建议在规范中补充推荐 **"懒加载 (Lazy Loading)"** 模式。即在 `setup()` 中只加载通用资源，在 `pre_execute/execute` 收到特定 `pid` 时再加载该 PID 专属资源，并配合一个 LRU Cache (最近最少使用) 机制来卸载长期未使用的 PID 资源。
    *   **避免过度设计**: 不需要平台做复杂的资源调度，只需在 SDK 文档中给算法开发者提供这个 Best Practice 即可。

### 4.2. 参数校验自动化
*   **现状**: `get_info` 返回参数 schema，`execute` 接收 `user_params`。
*   **痛点**: 每个算法都需要在 `execute` 开头写一堆 `if param < min: raise Error` 的校验代码。
*   **建议**:
    *   **优化**: SDK 的 Runner 层应在调用算法的 `execute` 之前，自动根据 `get_info` 里的 schema 对 `user_params` 进行校验。如果校验失败，直接由 Runner 拦截并报错，无需进入算法逻辑。
    *   **收益**: 减少算法代码的样板代码 (Boilerplate)，提升稳定性。

### 4.3. 共享内存的生命周期
*   **现状**: 平台写入，算法读取。
*   **风险**: 规范未明确说明共享内存块的**释放责任**。如果算法在 `diagnostics` 中引用了共享内存 ID 用于调试图，平台何时能安全回收这块内存？
*   **建议**:
    *   **明确**: 明确规定共享内存的"借用"周期。通常应仅在当前 `execute` 调用期间有效。如果算法需要跨周期保留（如存入 `session`），必须深拷贝（Deep Copy）。

### 4.4. 调试图传输优化
*   **现状**: 算法将调试图写入共享内存，返回 ID。
*   **优化**: 对于简单的调试（如画框、写字），算法直接返回 `overlay` 坐标即可，**不要**生成新的图像写入共享内存。只有在进行了复杂的图像处理（如二值化、频域变换）需要展示中间结果时，才使用共享内存传输图片。这能显著减少内存带宽压力。

## 5. 总结

这份 v0.2.0 规范是一份高质量的工业级接口文档。它成功地在灵活性（支持多PID）和约束性（禁止Base64传图、强制离线包结构）之间取得了平衡。

**建议立即执行的行动**:
1.  在 SDK 实现中增加 `user_params` 的自动 Schema 校验。
2.  在开发文档中增加关于"多模型懒加载"的代码示例。
